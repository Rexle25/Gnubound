<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Wandercode Play mit Sensor</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    textarea { width: 100%; height: 150px; }
    #gameArea > * { margin: .5rem 0; }
    img { max-width: 100%; }
  </style>
</head>
<body>

  <h1 id="titel">Gib dein Bound-JSON ein und starte:</h1>
  <textarea id="textInput">
{
  "title": "Meine Gurkenmission",
  "stations": [
    {
      "id": 1,
      "type": "question",
      "text": "Wie viele LÃ¶cher hat eine Socke?",
      "answer": "5",
      "imageUrl": "https://via.placeholder.com/150"
    },
    {
      "id": 2,
      "type": "gpsSound",
      "text": "Gehe zur Gurkenzentrale in Bern.",
      "lat": 46.948,
      "lng": 7.447,
      "radius": 50,
      "imageUrl": "https://via.placeholder.com/150"
    }
  ]
}
  </textarea><br>
  <button id="startBtn">Bound starten</button>

  <div id="gameArea"></div>

  <!-- Ping-Sound -->
  <audio id="pingSound" src="https://freesound.org/data/previews/341/341695_5260877-lq.mp3"></audio>

  <script>
    // 1. Global State
    let stations = [], currentIdx = 0;
    let watchId = null, heading = null, soundInterval = null;

    // 2. GerÃ¤tedrehung (Heading) erfassen
    window.addEventListener('deviceorientationabsolute', e => {
      if (e.absolute && e.alpha !== null) {
        heading = (360 - e.alpha) % 360;
      }
    });

    // 3. Bound starten
    document.getElementById('startBtn').onclick = () => {
      try {
        const bound = JSON.parse(document.getElementById('textInput').value);
        document.getElementById('titel').textContent = bound.title;
        stations = bound.stations;
        currentIdx = 0;
        document.getElementById('textInput').style.display = 'none';
        document.getElementById('startBtn').style.display = 'none';
        renderStation();
      } catch (e) {
        alert('UngÃ¼ltiges JSON: ' + e.message);
      }
    };

    // 4. Station rendern + GPS-Logik
    function renderStation() {
      const area = document.getElementById('gameArea');
      area.innerHTML = '';
      stopWatch();
      stopSound();

      if (currentIdx >= stations.length) {
        area.innerHTML = '<h2>ðŸŽ‰ Bound abgeschlossen!</h2>';
        return;
      }

      const st = stations[currentIdx];

      // Bild-Hinweis
      if (st.imageUrl) {
        const img = document.createElement('img');
        img.src = st.imageUrl;
        area.appendChild(img);
      }

      // Text
      const p = document.createElement('p');
      p.textContent = st.text;
      area.appendChild(p);

      if (st.type === 'question') {
        // Quiz-Station
        const inp = document.createElement('input');
        const btn = document.createElement('button');
        btn.textContent = 'Antwort prÃ¼fen';
        btn.onclick = () => {
          if (inp.value.trim().toLowerCase() === st.answer.toLowerCase()) {
            currentIdx++;
            renderStation();
          } else {
            alert('Falsch â€“ versuchâ€™s nochmal.');
          }
        };
        area.append(inp, btn);

      } else if (st.type === 'gps') {
        // Normaler GPS-Stationstyp
        startWatch();
        const btn = document.createElement('button');
        btn.textContent = 'Ziel erreicht?';
        btn.onclick = () => {
          navigator.geolocation.getCurrentPosition(pos => {
            const d = distance(pos.coords.latitude, pos.coords.longitude, st.lat, st.lng);
            if (d <= st.radius) {
              currentIdx++;
              renderStation();
            } else {
              alert(`Noch ${Math.round(d)} m bis zum Ziel.`);
            }
          }, () => alert('GPS-Fehler'));
        };
        area.appendChild(btn);

      } else if (st.type === 'gpsSound') {
        // GPS mit Sound-Feedback
        startWatch();
        startSound(st);
        const btn = document.createElement('button');
        btn.textContent = 'Ziel erreicht?';
        btn.onclick = () => {
          navigator.geolocation.getCurrentPosition(pos => {
            const d = distance(pos.coords.latitude, pos.coords.longitude, st.lat, st.lng);
            if (d <= st.radius) {
              currentIdx++;
              renderStation();
            } else {
              alert(`Noch ${Math.round(d)} m bis zum Ziel.`);
            }
          }, () => alert('GPS-Fehler'));
        };
        area.appendChild(btn);
      }
    }

    // 5. Geolocation-Watcher starten/stoppen
    function startWatch() {
      stopWatch();
      watchId = navigator.geolocation.watchPosition(() => {}, err => {}, { enableHighAccuracy: true });
    }
    function stopWatch() {
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
    }

    // 6. Sound-Feedback (Sheikah Sensor) alle 1 s
    function startSound(st) {
      stopSound();
      soundInterval = setInterval(() => {
        navigator.geolocation.getCurrentPosition(pos => {
          if (heading === null) return;
          const bear = bearing(pos.coords.latitude, pos.coords.longitude, st.lat, st.lng);
          const angleDiff = Math.abs(shortestAngleDiff(heading, bear));
          if (angleDiff <= 36) {
            document.getElementById('pingSound').play();
          }
        });
      }, 1000);
    }
    function stopSound() {
      if (soundInterval !== null) {
        clearInterval(soundInterval);
        soundInterval = null;
      }
    }

    // 7. Hilfsfunktionen

    // Distanz in Meter (Haversine-Formel)
    function distance(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const Ï†1 = lat1 * Math.PI / 180;
      const Ï†2 = lat2 * Math.PI / 180;
      const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
      const Î”Î» = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(Î”Ï†/2)**2 + Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin(Î”Î»/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // Peilung berechnen (Azimut)
    function bearing(lat1, lon1, lat2, lon2) {
      const Ï†1 = lat1 * Math.PI / 180;
      const Ï†2 = lat2 * Math.PI / 180;
      const Î”Î» = (lon2 - lon1) * Math.PI / 180;
      const y = Math.sin(Î”Î») * Math.cos(Ï†2);
      const x = Math.cos(Ï†1)*Math.sin(Ï†2) -
                Math.sin(Ï†1)*Math.cos(Ï†2)*Math.cos(Î”Î»);
      return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }

    // KÃ¼rzeste Winkel-Differenz zwischen zwei Winkeln
    function shortestAngleDiff(a, b) {
      return ((b - a + 540) % 360) - 180;
    }
  </script>
</body>
</html>
